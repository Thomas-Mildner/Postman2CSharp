@page "/ApiClient-Configurations-Explained"

<PageHeader Keywords="Explanations, Explained, Configure" Title="Configuring ApiClient Generation" SubTitle="Take even more control over your Api Clients by configuring ApiClient Generation Options."></PageHeader>

<BreadCrumbs Items="@BreadCrumbs"></BreadCrumbs>

<MudText Typo="Typo.h1" Class="mt-4">ApiClient Configurations Explained</MudText>
<br/>
<MudDivider Class="my-divider" DividerType="DividerType.FullWidth"></MudDivider>


@Explanation("Ensure Response Status Code", EnsureResponseStatusCode_False, EnsureResponseStatusCode_True)

<MudDivider Class="my-divider" DividerType="DividerType.FullWidth"></MudDivider>

@Explanation("Make Path Collection Variables Function Parameters", MakePathCollectionVariablesFunctionParameters_False, MakePathCollectionVariablesFunctionParameters_True, MakePathCollectionVariablesFunctionParameters_Description)

<MudDivider Class="my-divider" DividerType="DividerType.FullWidth"></MudDivider>

@Explanation("Use Cancellation Tokens", UseCancellationTokens_False, UseCancellationTokens_True)


<MudDivider Class="my-divider" DividerType="DividerType.FullWidth"></MudDivider>

<div>
    <MudText Typo="Typo.h3">Attribute Library</MudText>
    <br/>
    <p>
        You have two attribute libraries that you can choose from. System.Text.Json and Newtonsoft.Json.
        The attribute library you choose will have two affects. First, it will determine which JsonProperty Attribute
        to properties/fields on generated request and response classes. Secondly, it will determine which set of
        json extension methods your project is downloaded with. If you are unsure which to choose, choose System.Text.Json.
        Additionally, all Newtonsoft.Json extension methods have Newtonsoft in them. GetAsJsonAsync (STJ) => GetAsNewtonsoftJsonAsync (Newtonsoft).
    </p>
</div>

<MudDivider Class="my-divider" DividerType="DividerType.FullWidth"></MudDivider>

<div>
    <MudText Typo="Typo.h3">Multiple Response Handling</MudText>
    <br/>
    <p>
        Enabling this setting is a great way to ensure that you are handling all possible responses from an api.
        When you enabled this setting, the status code of the response will be used to determine how the response is deserialized.
    </p>
    <br />
    <p>
        <b>Handle:</b> The first option you have is whether or not you handle multiple responses at all. If you choose not to handle multiple response,
        then only the first success response - status code &gt;= 200 and &lt; 300, preference to 200 if present - will be uses in the generation process. 
        All others will be discarded. <u>This means that classes won't be generated for all other responses, this setting can't be enabled after generation.</u>
    </p>
    <br/>
    <p>
        <b>Multiple Response Handling:</b> If you do decide to handle multiple responses by setting "Handle" to true, then you will need to decide
        what you want the return type to be when there are multiple responses. You can either return an object and allow the caller to determine the type... ew.
        Or you can use a discriminated union via the popular OneOf library. A discriminated union is a type that can be one of many types, but only ever ONE OF.
        In this case, the discriminated union will be one of the possible response types. This is the recommended option.
    </p>
    <br/>
    <PrismCodeBlock Language="PrismLanguage.CSharp" Value="@ErrorHandlingStrategy_ThrowException" />
</div>

<MudDivider Class="my-divider" DividerType="DividerType.FullWidth"></MudDivider>

<div>
    <MudText Typo="Typo.h3">Xml Comments Type</MudText>
    <br/>
    <p>
        You have full control over the type of xml comments that are generated. Xml comments are generated
        from the description field of different parameters. Your options are ApiClient, QueryParameters, FormData,
        PathVariables, and Request. These are the locations of the generated xml comments. ApiClient: Appear at the top
        of generated ApiClient, description comes from root item description. QueryParameters: Each variable in the generated
        Parameters class will have an xml summary based on the description of the query parameters. FormData: Same as before but for FormData.
        PathVariables: An xml param tag will be generated on the ApiClient function for each path variable. Request: An xml summary will
        be generated on the ApiClient function from the description of the postman request item.
    </p>
</div>

<MudDivider Class="my-divider" DividerType="DividerType.FullWidth"></MudDivider>

<div>
    <MudText Typo="Typo.h3">Error Handling Strategy</MudText>
    <br/>
    <p>None - Request will be with no catch clause.</p>
    <br/>
    <PrismCodeBlock Language="PrismLanguage.CSharp" Value="@ErrorHandlingStrategy_ThrowException" />
    <hr/>
    <PrismCodeBlock Language="PrismLanguage.CSharp" Value="@ErrorHandlingStrategy_ReturnDefault" />
</div>

<MudDivider Class="my-divider" DividerType="DividerType.FullWidth"></MudDivider>

<div>
    <MudText Typo="Typo.h3">Catch Exception Types</MudText>
    
    <br/>
    <p>Each catch type chosen will be caught. Only takes affect if Error Handling Strategy is not None</p>
    <br/>
    <PrismCodeBlock Language="PrismLanguage.CSharp" Value="@CatchExceptionTypes_Example" />
</div>

<MudDivider Class="my-divider" DividerType="DividerType.FullWidth"></MudDivider>

<div>
    <MudText Typo="Typo.h3">Error Handling Sinks</MudText>

    <br />
    <PrismCodeBlock Language="PrismLanguage.CSharp" Value="@ErrorHandlingSinks_Example" />
</div>

<MudDivider Class="my-divider" DividerType="DividerType.FullWidth"></MudDivider>

<div>
    <MudText Typo="Typo.h3">Root Definition</MudText>

    <br/>
    <p>
        Api Clients are generated for each root in the Collection. By default a root is defined by any folder that has a request.
        Also by default, if there are requests that have different authority in a root, they will be split up into different Api Clients;
        Enabling this settings triggers a complete reorganization of the structure to put all requests with the same authority in the same root.
        This can cause unexpected behaviour including the loss of authorization types however it can drastically reduce the number of ApiClients and classes generated.
    </p>
</div>

<MudDivider Class="my-divider" DividerType="DividerType.FullWidth"></MudDivider>

<div>
    <MudText Typo="Typo.h3">Class Deduding</MudText>

    <br />
    <p>
        By default, with all other settings disabled. Root classes are never deduped, and non-root classes are only deduped
        when every single property matches by name and type on the original and duplicate and their property counts match.
    </p>
    <ul>
        <li>Root: A class that's not a member of any other class</li>
        <li>Non-Root: A class generated to be a member of another class.</li>
        <li>Json Example: A key-value pair in json. In this section, it generally refers to a key-value pair where the value is an object. Denoted by "{}" in value. "person" : { }</li>
        <li>Original Name: A value of the key in the json example.</li>
        <li>Duplicate: A json example who's members match every single member by type and name on a previously process json example. <u>And the original and potential duplicate have the exact same amount of properties.</u></li>
        <li>Semi-Duplicate: A json example who's members match every single member by type and name on a previously process json example. <u>And the original (already processed) has more properties than the potential duplicate.</u></li>
    </ul>
    <p>
        <b>Duplicate Roots:</b> You are given a couple of options to help reduce the number of classes generated. The first option lets you choose
        whether or not to remove duplicate ROOT classes. A root class is essentially one that is not a child of another class.
        These are your Request, Response, and Parameter classes. * Note: Root classes are subject to the same rules for deduping as non-root classes.
    </p>
    <br/>
    <p>
        <b>Semi-Duplicate Classes:</b> The second option lets you choose whether or not to remove "semi-duplciates", see definition above. Enabling this setting lets you dedupe these semi-duplicate classes. This is useful for json that
        has multiple examples of the same class but examples differ in name. For example, if you have Response that both have a Person object, but the json property names
        are different, this setting would let you dedupe the second example and put all unique properties in the first example. You are also able to adjust the sensitivity of this
        settings. The sensitivity is how many more properties the original can have than the duplicate. For example, if the original has 3 properties and the duplicate has 2 (all matching the original).
        The Same Original Name Sensitivity or Different Name Sensitivity would have to be at least 6, depending on whether the names are the same or different.
    </p>
    <br/>
    <p>
        <b>One Type Per Json Member Name:</b> At the moment, this setting is only available for the <a class="link-normal" href="/other-tools/json-to-csharp-plus">Json2CSharpPlus</a> tool found in other tools.
        Enabling this setting will enforce an additional rule during the dedupe process. Class deduping will work the same but 2 classes have the same name (in the json),
        the first one will be kept and all examples after will add their properties to the first class. This is useful for json that has multiple examples of the same object
        but examples have different amounts of properties. It is not useful when two classes have the same name but represent different models. Then you will have one model
        to represent 2 objects. The default depends is create a second class with a number appended to the end if all the properties don't match.
    </p>
</div>

<br/>

@code
{
    private static readonly List<BreadcrumbItem> BreadCrumbs = new()
    {
        new("Home", "/", icon: Icons.Home),
        new("Convert", "/Convert", icon: Icons.Settings),
        new("ApiClient Configurations Explained", "/ApiClient-Configurations-Explained", true)
    };

    #region EnsureResponseStatusCode
private const string EnsureResponseStatusCode_False =
@"// EnsureResponseStatusCode = false

var response = await _httpClient.GetAsync(queryString);
return await response.Content.ReadAsStreamAsync();";

    private const string EnsureResponseStatusCode_True =
@"// EnsureResponseStatusCode = true

var response = await _httpClient.GetAsync(queryString);
response.EnsureSuccessStatusCode();
return await response.Content.ReadAsStreamAsync();";
    #endregion

    #region MakePathCollectionVariablesFunctionParameters

    public const string MakePathCollectionVariablesFunctionParameters_Description =
@"By default, path parameters become function parameters and collection variables in paths become instance variables of the ApiClient.
This changes that and makes collection variables function parameters.";

    public const string MakePathCollectionVariablesFunctionParameters_False =
@"// MakePathCollectionVariablesFunctionParameters = false

private readonly string _someVariable; // Priate variable
public async Task<List<Ticket>> GetTickets()
{
    return await _httpClient.GetFromJsonAsync<List<Ticket>>(""{_someVariable}/ticket.php"");
}";
    
    public const string MakePathCollectionVariablesFunctionParameters_True = 
@"// MakePathCollectionVariablesFunctionParameters = true

// No priate Variable
public async Task<Stream> GetTickets(string someVariable) // Now a function parameter
{
    return await _httpClient.GetFromJsonAsync<List<Ticket>>(""{_someVariable}/ticket.php"");
}";
    #endregion

    #region CancellationTokens

        public const string UseCancellationTokens_False =
@"// UseCancellationTokens = false

public async Task<Stream> GetTickets()
{
    var response = await _httpClient.GetAsync(""{_someVariable}/ticket.php"");
    return await response.Content.ReadAsStreamAsync();
}";
    
        public const string UseCancellationTokens_True =
@"// UseCancellationTokens = true

public async Task<Stream> GetTickets(CancellationToken cancellationToken) // Now a function parameter
{
    var response = await _httpClient.GetAsync(""{someVariable}/ticket.php"", cancellationToken);
    return await response.Content.ReadAsStreamAsync(cancellationToken);
}";
    #endregion

    #region ErrorHandlingStrategy

    public const string ErrorHandlingStrategy_ReturnDefault =
@"// Return Default
try
{
    // Request body
}
catch (HttpRequestException ex)
{
    // Error Handling Sinks
    return default;
}";

    public const string ErrorHandlingStrategy_ThrowException =
@"// Thrown Exception
try
{
    // Request body
}
catch (HttpRequestException ex)
{
    // Error Handling Sinks
    throw;
}";
    #endregion

    #region CatchExceptionTypes

    public const string CatchExceptionTypes_Example =
@"// HttpRequestException and Exception
try
{
    // Request body
}
catch (HttpRequestException ex)
{
    // Error Handling Sinks
    throw;
}
catch (Exception ex)
{
    // Error Handling Sinks
    throw;
}";

    #endregion

    #region ErrorHandlingSinks
    public const string ErrorHandlingSinks_Example =
@"catch (// CatchExceptionType ex)
{
    _logger.LogError(ex); // Log Exception
    Console.WriteLine(ex); // Console Writeline
    Debug.WriteLine(ex); // Debug Writeline
    // Error Handling Strategy
}";
    #endregion

    #region MultipleResponses

    public const string MultipleResponse_ObjectExample =
@"
";

    #endregion

    public static RenderFragment Explanation(string title, string falsee, string truee, string? description = null)
    {
        return @<div>
                   <MudText Typo="Typo.h3">@title</MudText>
                   @if (description != null)
                   {
                       <br/>
                       <p>
                           @description
                       </p>
                   }
                   <br/>
                   <PrismCodeBlock Language="PrismLanguage.CSharp" Value="@falsee" />
                   <hr/>
                   <PrismCodeBlock Language="PrismLanguage.CSharp" Value="@truee" />
               </div>;
    }
}
