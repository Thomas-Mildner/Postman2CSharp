@using CodeBeamMudExtensions
<style>
    .setting-section-header {
        margin-bottom: 10px;
        font-weight: 100;
    }

    .my-step-container {
        background: rgb(23 26 34);
        padding: 15px;
        border: 1px solid white;
        border-top: 0px;
    }
</style>
<div class="f-row-column" style="gap: 10px;">
    <div class="f-column small-w-100" style="width: 90%;">
        <MudText>
            The best way to learn how these configurations work is to mess around with the <a class="link-normal" href="/Interactive-Demo">Interactive Demo</a>.
            For an in depth explanation on how these settings work, see
            <a class="link-normal" href="/ApiClient-Configurations-Explained">ApiClient Configurations Explanation</a>.
        </MudText>
    </div>
</div>
<br />

<MudStepper @ref="_stepper" Linear="true" Color="Color.Primary" Variant="Variant.Filled" UseStepBorder="true"
            DisableAnimation="false" ValidateStep="ValidateStep" ActiveStepChanged="OnActiveIndexChanged" >
    <MudStep Title="Upload">
        <div class="my-step-container" style="min-height: 50vh;"  >
            <CollectionUpload Small="false" SuccessfulUpload="args => { _uploadedFile = args.BrowserFile; _collection = args.Collection; }"></CollectionUpload>
        </div>
    </MudStep>
    <MudStep Title="Json">
        <StepperItem >
            <Input>
                <EnumSelectComponent TEnum="JsonLibrary" @bind-Value="_dirtyApiClientOptions.JsonLibrary" Label="Json Library"></EnumSelectComponent>
                <EnumSelectComponent TEnum="JsonPropertyAttributeUsage" @bind-Value="_dirtyApiClientOptions.AttributeUsage" Label="JsonProperty Attribute Usage"></EnumSelectComponent>
            </Input>
            <Example>
                <PrismCodeBlock Language="PrismLanguage.CSharp" UseLineNumbers="false" DisplayType="CodeBlockDisplayType.Scroll" MaxHeight="50vh" MaxWidth="40vw">
@if (_dirtyApiClientOptions.JsonLibrary == JsonLibrary.SystemTextJson)
{
    <text>
public class Example
{
    [JsonPropertyName("property_name")]
    public string PropertyName { get; set; }
}

public static async Task&lt;T&gt; ReadJsonAsync&lt;T&gt;(this HttpResponseMessage response, JsonSerializerOptions? jsonSerializerOptions = null)
{
    var stringContent = await response.Content.ReadAsStringAsync();
    return JsonSerializer.Deserialize&lt;T&gt;(stringContent, jsonSerializerOptions ?? JsonSerializerOptions)!;
}
    </text>
}
else
{
    <text>
public class Example
{      
    [JsonProperty("property_name")]
    public string PropertyName { get; set; }
}

public static async Task&lt;T&gt; ReadNewtonsoftJsonAsync&lt;T&gt;(this HttpResponseMessage response,
    JsonSerializerSettings serializerSettings = null)
{
    var stringContent = await response.Content.ReadAsStringAsync();
    return JsonConvert.DeserializeObject&lt;T&gt;(stringContent, serializerSettings ?? _jsonSerializerSettings);
}
    </text>
}

                </PrismCodeBlock>
            </Example>
            <AdditionalInfo>
                <MudText Typo="Typo.h6" >Attribute Usage</MudText>
                <ul>
                    <li>
                        @InlineValue("Always") - Always add attribute to properties
                    </li>
                    <li>
                        @InlineValue("OnlyWhenNecessary") - Attribute will only be applied to properties with names that cannot be expressed as C# identifiers
                    </li>
                    <li>
                        @InlineValue("Never") - Attribute will never be applied to properties.
                    </li>
                </ul>
            </AdditionalInfo>
        </StepperItem>
    </MudStep>
    <MudStep Title="Multiple Response Handling">
        <StepperItem >
            <Input>
                <MudCheckBox Color="Color.Primary" @bind-Checked="_dirtyApiClientOptions.HandleMultipleResponses">Handle Multiple Responses</MudCheckBox>
                <EnumSelectComponent TEnum="MultipleResponseHandling" @bind-Value="_dirtyApiClientOptions.MultipleResponseHandling" Disabled="_dirtyApiClientOptions.HandleMultipleResponses == false" Label="Return Type"></EnumSelectComponent>
            </Input>
            <Example>
                <PrismCodeBlock Language="PrismLanguage.CSharp" UseLineNumbers="false" DisplayType="CodeBlockDisplayType.Scroll" MaxHeight="50vh" MaxWidth="40vw" >
                    @if (_dirtyApiClientOptions.HandleMultipleResponses)
                    {
                        var typeParam = _dirtyApiClientOptions.MultipleResponseHandling switch
                        {
                            MultipleResponseHandling.OneOf => "OneOf<SearchUsersOKResponse, SearchUsersUnauthorizedResponse, SearchUsersForbiddenResponse, SearchUsersInternalServerErrorResponse>",
                            MultipleResponseHandling.Object => "object",
                            _ => throw new Exception("Invalid MultipleResponseHandling")
                        };
                        <text>
public async Task&lt;@typeParam&gt; SearchUsers(SearchUsersParameters queryParameters)
{
    var parametersDict = queryParameters.ToDictionary();
    var queryString = QueryHelpers.AddQueryString($"{_version}/users", parametersDict);
    var response = await _httpClient.GetAsync(queryString);
    if (response.StatusCode == HttpStatusCode.OK)
    {
        return await response.ReadJsonAsync&lt;SearchUsersOKResponse&gt;();
    }
    else if (response.StatusCode == HttpStatusCode.Unauthorized)
    {
        return await response.ReadJsonAsync&lt;SearchUsersUnauthorizedResponse&gt;();
    }
    else if (response.StatusCode == HttpStatusCode.Forbidden)
    {
        return await response.ReadJsonAsync&lt;SearchUsersForbiddenResponse&gt;();
    }
        else if (response.StatusCode == HttpStatusCode.InternalServerError)
    {
        return await response.ReadJsonAsync&lt;SearchUsersInternalServerErrorResponse&gt;();
    }
    else
    {
        throw new Exception($"SearchUsers: Unexpected response. Status Code: {response.StatusCode}. Content: {await response.Content.ReadAsStringAsync()}");
    }
}
                        </text>
                    }
                    else
                    {
                        <text>
public async Task&lt;SearchUsersResponse&gt; SearchUsers(SearchUsersParameters queryParameters)
{
    var parametersDict = queryParameters.ToDictionary();
    return await _httpClient.GetFromJsonAsync&lt;SearchUsersResponse&gt;($"{_version}/users", parametersDict);
}
                        </text>
                    }
                </PrismCodeBlock>
            </Example>
        </StepperItem>
    </MudStep>
    <MudStep Title="Error Handling">
        <StepperItem>
            <Input>
                <EnumSelectComponent @bind-Value="_dirtyApiClientOptions.ErrorHandlingStrategy" AlwaysShowAllEnumValues Label="Error Handling Strategy"></EnumSelectComponent>
                <MultiEnumSelectComponent Disabled="_dirtyApiClientOptions.ErrorHandlingStrategy == ErrorHandlingStrategy.None" TEnum="ErrorHandlingSinks" Value="_dirtyApiClientOptions.ErrorHandlingSinks" Label="Error Handling Sinks" SelectedValuesChanged="SelectedErrorHandlingSinksChanged"></MultiEnumSelectComponent>
                <MultiEnumSelectComponent Disabled="_dirtyApiClientOptions.ErrorHandlingStrategy == ErrorHandlingStrategy.None" TEnum="CatchExceptionTypes" Label="Catch Exception Types" ForbidNoValue Value="_dirtyApiClientOptions.CatchExceptionTypes" SelectedValuesChanged="SelectedCatchExceptionTypesChanged"></MultiEnumSelectComponent>
                <EnumSelectComponent Disabled="_dirtyApiClientOptions.ErrorHandlingStrategy == ErrorHandlingStrategy.None || !_dirtyApiClientOptions.ErrorHandlingSinks.Contains(ErrorHandlingSinks.LogException)" @bind-Value="_dirtyApiClientOptions.LogLevel" AlwaysShowAllEnumValues Label="Log Level"></EnumSelectComponent>
            </Input>
            <Example>
                <PrismCodeBlock Language="PrismLanguage.CSharp" UseLineNumbers="false" DisplayType="CodeBlockDisplayType.Scroll" MaxHeight="50vh" MaxWidth="40vw">
                    @if (_dirtyApiClientOptions.ErrorHandlingStrategy == ErrorHandlingStrategy.None)
                    {
                        <text>
public async Task&lt;Users&gt; GetUserById(string id)
{
    return await _httpClient.GetFromJsonAsync&lt;Users&gt;($"{_version}/users/{id}");
}
                        </text>
                    }
                    else
                    {
                        <text>
public async Task&lt;Users&gt; GetUserById(string id)
{
    try
    {
        return await _httpClient.GetFromJsonAsync&lt;Users&gt;($"{_version}/users/{id}");
    }
    @foreach(var catchExceptionType in _dirtyApiClientOptions.CatchExceptionTypes)
    {
    <text>
    catch (@catchExceptionType ex)
    {
    @foreach (var errorHandlingSink in _dirtyApiClientOptions.ErrorHandlingSinks)
    {
        var logFunction = _dirtyApiClientOptions.LogLevel switch
        {
            LogLevel.Trace => "LogTrace",
            LogLevel.Debug => "LogDebug",
            LogLevel.Information => "LogInformation",
            LogLevel.Warning => "LogWarning",
            LogLevel.Error => "LogError",
            LogLevel.Critical => "LogCritical",
            _ => throw new ArgumentOutOfRangeException(nameof(_dirtyApiClientOptions.LogLevel), _dirtyApiClientOptions.LogLevel, null)
        };
        switch (errorHandlingSink)
        {
            case ErrorHandlingSinks.ConsoleWriteLine:
            @($"{Consts.Indent(2)}Console.WriteLine(ex);\n")
            break;
        case ErrorHandlingSinks.LogException:
            @($"{Consts.Indent(2)}_logger.{logFunction}(ex);\n");
            break;
        case ErrorHandlingSinks.DebugWriteLine:
            @($"{Consts.Indent(2)}Debug.WriteLine(ex);\n")
            break;
        default:
            throw new ArgumentOutOfRangeException(nameof(_dirtyApiClientOptions.ErrorHandlingSinks), errorHandlingSink, null);
        }
    }
    @if (_dirtyApiClientOptions.ErrorHandlingStrategy == ErrorHandlingStrategy.ReturnDefault)
    {
        @($"{Consts.Indent(2)}return default;\n")
    }
    else 
    {
        @($"{Consts.Indent(2)}throw;\n")
    }
    }
</text>
}
}
                        </text>
                    }
                </PrismCodeBlock>
            </Example>
        </StepperItem>
    </MudStep>
    <MudStep Title="Function Configurations">
        <StepperItem>
            <Input>
                <MudCheckBox Color="Color.Primary" @bind-Checked="_dirtyApiClientOptions.MakePathCollectionVariablesFunctionParameters">Make Path Collection Variables Function Parameters</MudCheckBox>
                <MudCheckBox Color="Color.Primary" @bind-Checked="_dirtyApiClientOptions.UseCancellationTokens">Use Cancellation Tokens</MudCheckBox>
                <MudCheckBox Color="Color.Primary" @bind-Checked="_dirtyApiClientOptions.ExecuteWithRetry">Execute With Retry</MudCheckBox>
            </Input>
            <Example>
                <PrismCodeBlock Language="PrismLanguage.CSharp" UseLineNumbers="false" DisplayType="CodeBlockDisplayType.Scroll" MaxHeight="50vh" MaxWidth="40vw">
                    @{
                        var comment = _apiClientOptions.MakePathCollectionVariablesFunctionParameters
                            ? "// No private Variable"
                            : "private readonly string _somePathCollectionVariable; // Private variable";
                        var secondComment = _apiClientOptions.MakePathCollectionVariablesFunctionParameters
                            ? "// Now a function parameter"
                            : "";
                        var variableName = _apiClientOptions.MakePathCollectionVariablesFunctionParameters ? "somePathCollectionVariable" : "_somePathCollectionVariable";
                        string parameters = "";
                        if (_apiClientOptions.MakePathCollectionVariablesFunctionParameters)
                        {
                            parameters = "string somePathCollectionVariable";
                            if (_apiClientOptions.UseCancellationTokens)
                            {
                                parameters += ", CancellationToken cancellationToken";
                            }
                        }
                        else
                        {
                            if (_apiClientOptions.UseCancellationTokens)
                            {
                                parameters = "CancellationToken cancellationToken";
                            }
                        }
                    
                        var cancellationTokenValue = _dirtyApiClientOptions.UseCancellationTokens ? ", cancellationToken: cancellationToken" : "";
                    }
@comment
public async Task&lt;Stream&gt; GetTickets(@parameters) @secondComment
{
@if (_dirtyApiClientOptions.ExecuteWithRetry)
{
    @($"{Consts.Indent(1)}return await ExecuteWithRetry(() => _httpClient.GetStreamAsync($\"{{{variableName}}}/ticket.php\"{cancellationTokenValue}));\n")
}
else
{
    @($"{Consts.Indent(1)}return await _httpClient.GetStreamAsync($\"{{{variableName}}}/ticket.php\"{cancellationTokenValue});\n")
}
}
@if (_dirtyApiClientOptions.ExecuteWithRetry)
{
@:private async Task&lt;T&gt; ExecuteWithRetry&lt;T&gt;(Func&lt;Task&lt;T&gt;&gt; operation, int retryCount = 2,
@Consts.Indent(1)@:[CallerMemberName] string callerMemberName = "", [CallerFilePath] string sourceFilePath = "", [CallerLineNumber] int sourceLineNumber = 0)
@Consts.Indent(1)@:{
@Consts.Indent(2)@:// Logic for retrying on error
@Consts.Indent(2)@:// Tip: Replace with your own retry logic using a Poly pipeline/policy
@Consts.Indent(1)@:}
}
                </PrismCodeBlock>
            </Example>
        </StepperItem>
    </MudStep>
    <MudStep Title="Class Deduping">
        <StepperItem>
            <Input>
            <MudCheckBox Color="Color.Primary" @bind-Checked="_dirtyApiClientOptions.DuplicateOptions.RemoveDuplicateRoots">Dedupe Duplicate Roots</MudCheckBox>
            <MudCheckBox Color="Color.Primary" @bind-Checked="_dirtyApiClientOptions.DuplicateOptions.RemoveSemiDuplicates">Dedupe Semi-Duplicate Classes</MudCheckBox>
            <MudNumericField @bind-Value="_dirtyApiClientOptions.DuplicateOptions.SameOriginalNameSensitivity" Disabled="_dirtyApiClientOptions.DuplicateOptions.RemoveSemiDuplicates == false" Label="Same Json Name Sensitivity" Variant="Variant.Outlined" Step="1" Min="0" Max="50" />
            <MudNumericField @bind-Value="_dirtyApiClientOptions.DuplicateOptions.DifferentOriginalNameSensitivity" Disabled="_dirtyApiClientOptions.DuplicateOptions.RemoveSemiDuplicates == false" Label="Different Json Name Sensitivity" Variant="Variant.Outlined" Step="1" Min="0" Max="6" />
            </Input>
            <Example>
                <PrismCodeBlock Language="PrismLanguage.CSharp" UseLineNumbers="false" DisplayType="CodeBlockDisplayType.Scroll" MaxHeight="50vh" MaxWidth="40vw">
@{
    var getUserReturnType = "GetUserResponse";
    var postUserReturnType = "PostUserResponse";
    var patchUserReturnType = "PatchUserResponse";
    if (_dirtyApiClientOptions.DuplicateOptions.RemoveDuplicateRoots)
    {
        postUserReturnType = getUserReturnType;
        if (_dirtyApiClientOptions.DuplicateOptions is { RemoveSemiDuplicates: true, DifferentOriginalNameSensitivity: > 1 })
        {
            patchUserReturnType = getUserReturnType;
        }
    }
}
// GetUserById and PostUser both return the exact same json.
// PatchUser returns the extremely similar json but with 2 fewer properties.
// Same Json Name Sensitivity has no effect in this scenario. Json roots are
// all have different json names during deduping (even though they are roots
// and technically have no name).
public async Task&lt;@getUserReturnType&gt; GetUserById(string id)
{
    return await _httpClient.GetFromJsonAsync&lt;Users&gt;($"{_version}/users/{id}");
}

public async Task&lt;@postUserReturnType&gt; PostUser(User user)
{
    return await _httpClient.GetJsonAsync&lt;Users&gt;($"{_version}/users", user);
}

public async Task&lt;@patchUserReturnType&gt; PatchUser(User user)
{
    return await _httpClient.PatchJsonAsync&lt;Users&gt;($"{_version}/users", user);
}
                </PrismCodeBlock>
            </Example>
            <AdditionalInfo>
                <div style="overflow: scroll;">
                    <ul>
                        <li>
                            @InlineEmphasis("Duplicate Roots") - The root class ares your responses and requests; all other classes generated descend from them. Deduping them
                            will cause some endpoints to return the same model, rather than all returning a unique model.
                        </li>
                        <li>
                            @InlineValue("Semi-Duplicate Classes") - A semi-duplicate class is a class that has that has all matching members to another class, except fewer.
                            It's not uncommon to see JSON responses representing the same model with different amounts of properties. This is usually because the API is returning
                            a subset of the properties in the model. Enabling this will dedupe these "semi-duplicate".
                        </li>
                        <li>
                            @InlineValue("Same vs Different Json Name Sensitivity") - If you enable removing semi-duplicates, you probably want to set limits on the difference in the amount
                            of properties on 2 classes can be to be considered a semi-duplicate - you don't want an error response with only a message property being deduped into the chat message class.
                            The same sensitivity is the the difference in the amount of properties on 2 classes can be to be considered semi-duplicate if they have the same json name.
                            The different sensitivity functions the same but when the json names (keys) are different. Higher sensitivity = more likely to be considered a semi-duplicate = higher change
                            of deduping classes that don't represent the same model. Semi duplicate options apply to duplicate roots.
                        </li>
                    </ul>
                </div>
            </AdditionalInfo>
        </StepperItem>
    </MudStep>
    <MudStep Title="Miscellaneous">
    <StepperItem>
        <Input>
            <MultiEnumSelectComponent TEnum="XmlCommentTypes" Value="_dirtyApiClientOptions.XmlCommentTypes" Label="Comment Types" SelectedValuesChanged="SelectedCommentTypesChanged"></MultiEnumSelectComponent>
            <MultiEnumSelectComponent TEnum="RemoveDisabled" Value="_dirtyApiClientOptions.RemoveDisabled" Label="Remove Disabled" SelectedValuesChanged="SelectedRemovedDisabledChanged"></MultiEnumSelectComponent>
            <EnumSelectComponent @bind-Value="_dirtyApiClientOptions.RootDefinition" Exclude="new List<RootDefinition>() { RootDefinition.Manual }" AlwaysShowAllEnumValues Label="Root Definition"></EnumSelectComponent>
        </Input>
        <Example>
            <PrismCodeBlock Language="PrismLanguage.CSharp" UseLineNumbers="false" DisplayType="CodeBlockDisplayType.Scroll" MaxHeight="50vh" MaxWidth="40vw" >

@if (_dirtyApiClientOptions.XmlCommentTypes.Contains(XmlCommentTypes.ApiClient))
{
@($@"/// <summary>
/// Comment from root item in postman.
/// </summary>
")
}
public class ExampleApiClient : IExampleApiClient
{
    private readonly HttpClient _httpClient;
    public ExampleApiClient(HttpClient httpClient, IConfiguration config)
    {
        _httpClient = httpClient;
        _httpClient.BaseAddress = new Uri($"https://someurl.com/api/");
    }

@if (_dirtyApiClientOptions.XmlCommentTypes.Contains(XmlCommentTypes.Request))
{
@($@"{Consts.Indent(1)}/// <summary>
{Consts.Indent(1)}/// Comment from postman request.
{Consts.Indent(1)}/// </summary>
")
}
@if (_dirtyApiClientOptions.XmlCommentTypes.Contains(XmlCommentTypes.PathVariables))
{
@($"{Consts.Indent(1)}/// <param name=\"id\">The id of the user</param>\n")
}
@{
    var parameters = "$\"{id}\"";
    if (!_dirtyApiClientOptions.RemoveDisabled.Contains(RemoveDisabled.Headers))
    {
        parameters += ", headers";
    }
}
    public async Task&lt;SearchUsersResponse&gt; GetUsers(string id)
    {
@if (!_dirtyApiClientOptions.RemoveDisabled.Contains(RemoveDisabled.Headers))
{
    @($@"{Consts.Indent(2)}var headers = new Dictionary<string, string>();
{Consts.Indent(2)}{{
{Consts.Indent(3)}{{ $""DisabledHeader"", $""value"" }}
{Consts.Indent(2)}}};
")
}
        return await _httpClient.GetFromJsonAsync&lt;SearchUsersResponse&gt;(@parameters);
    }
}

public class SomeFormData : IFormData
{
@if (_dirtyApiClientOptions.XmlCommentTypes.Contains(XmlCommentTypes.FormData))
{
@($@"{Consts.Indent(1)}/// <summary>
{Consts.Indent(1)}/// Some comment
{Consts.Indent(1)}/// </summary>
")
}
    public string EnabledFormData { get; set; }
@if (!_dirtyApiClientOptions.RemoveDisabled.Contains(RemoveDisabled.FormData))
{
@($"{Consts.Indent(1)}public string DisabledFormData {{get; set; }}\n")
}
@{
    var kvpInitializer = "new(\"EnabledFormData\", EnabledFormData)";
    if (_dirtyApiClientOptions.XmlCommentTypes.Contains(XmlCommentTypes.FormData) == false)
    {
        kvpInitializer += ", new(\"DisabledFormData\", DisabledFormData)";
    }
}
    public FormUrlEncodedContent ToFormData()
    {
        return new FormUrlEncodedContent(new KeyValuePair&lt;string, string&gt;[] { @kvpInitializer });
    }
}

public class SomeQueryParameters(
{
@if (_dirtyApiClientOptions.XmlCommentTypes.Contains(XmlCommentTypes.QueryParameters))
{
@($@"{Consts.Indent(1)}/// <summary>
{Consts.Indent(1)}/// Some comment
{Consts.Indent(1)}/// </summary>
")
}
    public string EnabledQueryParameter { get; set; }
@if (!_dirtyApiClientOptions.RemoveDisabled.Contains(RemoveDisabled.QueryParameters))
{
    @($"{Consts.Indent(1)}public string DisabledQueryParameter {{get; set; }}\n")
}
}
            </PrismCodeBlock>
        </Example>
        <AdditionalInfo>
            <ul>
                <li>@InlineEmphasis("Root"): A root is any folder in a collection that has a request (including the root itself).</li>
                <li>@InlineEmphasis("Authority"): The authority component of a URL includes the authentication section, the host, and the port. In the URL http://username:password@example.com:8080/path/to/file - @InlineEmphasis("Authority"): @InlineCode("\"username:password@example.com:8080\"").</li>
                <Break Size="P2CsSize.Small"></Break>
                <li>@InlineValue("PerAuthorityPerFolder"): An ApiClient will be created for each root, with a caveat being that if a root uses different authorities in it's requests, the requests will be regrouped into new roots based on authority.</li>
                <ul>
                    <li>Useful when the postman collection is well organized and you want your ApiClients to have seperation of concerns</li>
                </ul>
                <li>@InlineValue("PerAuthority"): An ApiClient will be created for each authority disregarding the folders requests are in.</li>
                <ul>
                    <li>Useful when the you want a monolithic ApiClient.</li>
                </ul>
            </ul>
        </AdditionalInfo>
    </StepperItem>
</MudStep>
    <MudStep Title="Result" IsResultStep="true">
        <ProgressPopup Options="_progressOptions" IsPopup="false" />
    </MudStep>
</MudStepper>

@code {
    [Inject] private ISnackbar? Snackbar { get; set; }
    [Inject] private AnalyticsInterop AnalyticsInterop { get; set; } = null!;
    [Parameter] public EventCallback<ApiCollection> SuccessfulUpload { get; set; }

    private MudStepper? _stepper;
    private enum Steps
    {
        Upload,
        Json,
        MultipleResponseHandling,
        ErrorHandling,
        FunctionConfigurations,
        ClassDeduping,
        Miscellaneous,
        Result
    }

    private PostmanCollection? _collection;
    private IBrowserFile? _uploadedFile;


    private async Task OnActiveIndexChanged(int newIndex)
    {
        if (newIndex == (int) Steps.Result)
        {
            await InvokeAsync(StateHasChanged);
            await Task.Delay(10);
            await GenerateApiClientsWithTracking();
        }
    }
    private Task<bool> ValidateStep(StepChangeDirection stepDirection, int activeIndex)
    {
        if (stepDirection is StepChangeDirection.None or StepChangeDirection.Backward)
        {
            return Task.FromResult(true);
        }
        var step = (Steps)activeIndex;
        switch (step)
        {
            case Steps.Upload:
                return Task.FromResult(_collection != null && _uploadedFile != null);
            case Steps.Json:
                break;
            case Steps.MultipleResponseHandling:
                break;
            case Steps.ErrorHandling:
                break;
            case Steps.FunctionConfigurations:
                break;
            case Steps.ClassDeduping:
                break;
            case Steps.Miscellaneous:
                break;
            case Steps.Result:
                break;
            default:
                throw new ArgumentOutOfRangeException();
        }

        return Task.FromResult(true);
    }

    private void ResetAllStepsBefore(int index)
    {
        var step = (Steps)index;
        switch (step)
        {
            case Steps.Upload:
                break;
            case Steps.Json:
                break;
            case Steps.MultipleResponseHandling:
                break;
            case Steps.ErrorHandling:
                break;
            case Steps.FunctionConfigurations:
                break;
            case Steps.ClassDeduping:
                break;
            case Steps.Miscellaneous:
                break;
            case Steps.Result:
                break;
            default:
                throw new ArgumentOutOfRangeException();
        }
    }

    private void SetFutureStepsIncomplete(Steps step)
    {
        switch (step)
        {
            case Steps.Upload:
                goto case Steps.Json;
            case Steps.Json:
                goto case Steps.MultipleResponseHandling;
            case Steps.MultipleResponseHandling:
                goto case Steps.ErrorHandling;
            case Steps.ErrorHandling:
                goto case Steps.FunctionConfigurations;
            case Steps.FunctionConfigurations:
                goto case Steps.Miscellaneous;
            case Steps.Miscellaneous:
                break;
        }
        var futureSteps = _stepper.Steps.Skip((int) step + 1).ToList();
        foreach (var futureStep in futureSteps)
        {
            futureStep.Status = StepStatus.Continued;
        }
    }

    private ApiClientOptions _dirtyApiClientOptions = new();
    private ApiClientOptions _apiClientOptions = new();
    [Parameter]
    public ApiClientOptions ApiClientOptions
    {
        get => _apiClientOptions;
        set
        {
            if (ApiClientOptions.ConfigsEqual(_apiClientOptions, value))
            {
                return;
            }
            SetApiClientOptions(value);
        }
    }

    [Parameter]
    public EventCallback<ApiClientOptions> ApiClientOptionsChanged { get; set; }

    protected override void OnParametersSet()
    {
        if (!ApiClientOptions.ConfigsEqual(_dirtyApiClientOptions, ApiClientOptions))
        {
            SetApiClientOptions(ApiClientOptions);
        }
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (!ApiClientOptions.ConfigsEqual(_dirtyApiClientOptions, ApiClientOptions))
        {
            SetApiClientOptions(_dirtyApiClientOptions);
        }
    }

    public void SetApiClientOptions(ApiClientOptions options)
    {
        _apiClientOptions = options.Clone();
        _dirtyApiClientOptions = options.Clone();
        ApiClientOptionsChanged.InvokeAsync(options);
    }

    private void SelectedErrorHandlingSinksChanged(IEnumerable<string> errorHandlingSinks)
    {
        _dirtyApiClientOptions.ErrorHandlingSinks = errorHandlingSinks.Select(Enum.Parse<ErrorHandlingSinks>).ToList();
    }
    private void SelectedCatchExceptionTypesChanged(IEnumerable<string> catchTypes)
    {
        _dirtyApiClientOptions.CatchExceptionTypes = catchTypes.Select(Enum.Parse<CatchExceptionTypes>).ToList();
    }
    private void SelectedCommentTypesChanged(IEnumerable<string> commentTypes)
    {
        _dirtyApiClientOptions.XmlCommentTypes = commentTypes.Select(Enum.Parse<XmlCommentTypes>).ToList();
    }
    private void SelectedRemovedDisabledChanged(IEnumerable<string> commentTypes)
    {
        _dirtyApiClientOptions.RemoveDisabled = commentTypes.Select(Enum.Parse<RemoveDisabled>).ToList();
    }

    private void SaveOptions()
    {
        SetApiClientOptions(_dirtyApiClientOptions);
        Snackbar?.Add($"Saved {nameof(ApiClientOptions)}", Severity.Success);
    }

    private async Task GenerateApiClientsWithTracking()
    {
        if (_collection == null || _uploadedFile == null) return;
        try
        {
            var apiClientGenerator = new ApiClientGenerator(_collection, new ApiClientGeneratorOptions(CSharpCodeWriterOptionsComponent.Options, Convert.LastSavedApiClientOptions));
            await StartTrackingGenerator(apiClientGenerator);
            _forceRender = true;
            StateHasChanged();
            await Task.Delay(1);
            var apiClients = await apiClientGenerator.GenerateApiClients();
            var apiCollection = new ApiCollection()
            {
                ApiClients = apiClients,
                CollectionInfo = _collection.Info
            };

            var isTestData = _uploadedFile.Name == Consts.TestDataName;
            var dataType = isTestData ? "Test Data" : "Real Data";
            var message = $"Generate ApiClient - {dataType}";
            await AnalyticsInterop.TrackAction(message);
            await Task.Delay(5);
            await SuccessfulUpload.InvokeAsync(apiCollection);
        }
        catch (Exception exception)
        {
            if (_progressSnackbar != null)
            {
                Snackbar?.Remove(_progressSnackbar);
            }
            Snackbar?.Add($"Something went wrong. {exception.Message}", Severity.Error);
        }
    }

    private ProgressPopupOptions? _progressOptions;
    private Snackbar? _progressSnackbar;
    private async Task StartTrackingGenerator(ApiClientGenerator apiClientGenerator)
    {
        var options = new ProgressPopupOptions("Deserializing collection...", "Finished Generating ApiClients!");
        apiClientGenerator.ProgressCallback += options.InvokeProgressCallback;
        apiClientGenerator.OnStageChanged += options.InvokeStageChangedCallback;

        _progressOptions = options;
    }

    private bool _forceRender = false;
    private ApiClientOptions? _cachedApiClientsOptions;
    private ApiClientOptions? _cachedDirtyApiClientsOptions;
    protected override bool ShouldRender()
    {
        if (!_forceRender && _cachedApiClientsOptions != null && ApiClientOptions.ConfigsEqual(_cachedApiClientsOptions, _cachedDirtyApiClientsOptions)
            && ApiClientOptions.ConfigsEqual(_apiClientOptions, _dirtyApiClientOptions))
        {
            return false;
        }
        _forceRender = false;
        _cachedApiClientsOptions = _apiClientOptions.Clone();
        _cachedDirtyApiClientsOptions = _dirtyApiClientOptions.Clone();
        return true;
    }

}